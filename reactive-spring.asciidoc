[[Reactive Spring]]
:book-root: .

== Reactive Spring

== The Need for Async IO
At Pivotal we see a lot of organizations moving to microservices. The architecture emphasizes small, singly focused, independently deployable pieces of functionality. They're small because small implies a smaller team working on the codebase. They're singly focused because it's easier to stay small that way. They're independently deployable because that means you're never blocked by other teams in the organization. The architecture has a lot of benefits; it supports organizational agility. That said, it does have some drawbacks. The approach implies network distribution. The distribution in turn invites architectural complexity and things get difficult when dependencies fails. Things get difficult when networks fail. Things get difficult when the conduction of data between nodes becomes overwhelming.

Blocking IO creates problems when we when we say blocking we mean that for a client to read a byte from a file or a socket or whatever, it needs to wait for the byte to arrvie. the thread in which the read is happeing is idle, but unusable. this is a pity because it doesnt need to be thiis way. at lower levels in the OS, network IO is typiccally asynchronous. POSIX complpian OSes have supported the ability to poll filedesritptors ro IO activity and dispatch when there is someting to do.   the classic `select(fd*)` call supports this.

JDK 1.4 saw the introduction of NIO, the _new_ IO packages. NIO gaves us channels which allow asyncchronous IO. this sia marked improvement but youll notice that it hasnt exactly become the pervasive metaphor for computation. these ddays almost alll of the APIS typical of enterpriee  computing are blocking by default and you probabyl dont even realize it. hopefully, most of us arent wriing custom database drivers, http sweb stacks, and security technologies ourselves. were relying on tried and true implementations that sit below the value line, below the line of things that we feel the need to expend cognitive effort trying to understand. our business application i swhat matters, and so most frameworks let us think about the world in terms of our business domain, relegating IO concersn to the murky depths of the of the framework and app stack.

wee think about the world in terms of instances of ourdomain model entities, `T`, or collections of `T`. those are synchronous views on data. the `CompletableFuture<T>` gives us asyncchronous views of data. it lets us say that, eventually, we'll have a reference to a `t`. But we havent had for the longest time a way to say that we have a potentially infinite collection of type `T` that may or may not arrive asynchronously.

Such a metaphor would need to be coupled with a way to gate the production and consumption of values. In the world of finite data sets, producers may occasionally overwhelm consumers but a consumer has various knobs and levers it can pull to buffer extra work, allowing it to eventually get to it. This works because the buffer is sufficient to cocntain the overwhelming demand. But what happens if the production is infinite? eventually, as with a floodded boat whose occupants are desperately trying to bail the ocean's worth of water,   the consumer will sink. This is called flow control, and it needs to be a first class feature of any computational metaphor  we choose.




// == Reactive Spring
// So you've got that shiny new distributed runtime, infinite greenfield potential, and lots of existing applications; now what?((("application forklifting", id="ix_appfork")))
// Alternatively, you can specify the buildpack in the `manifest.yml` file that accompanies your application. As an example, suppose we have a Java EE application that has historically been deployed using IBM's WebSphere. IBM maintains a very capable WebSphere Liberty buildpack. To demonstrate this, let's say we want to deploy and run a basic  `Servlet` (<<example0502>>). (Let's ignore, for now, that we can run `Servlet` components in Spring Boot applications, as shown in <<using-servlet-apis-in-a-spring-boot-application>>.)
//
// [[example0502]]
// .A (very) basic Java EE Servlet
// ====
// [source,java,indent=0]
// ----
// include::{book-root}/forklifting/buildpacks/src/main/java/demo/DemoApplication.java[]
// ----
// ====
