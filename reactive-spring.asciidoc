[[Reactive Spring]]
:book-root: .

== Reactive Spring
by Josh Long (@starbuxman), Spring Developer Advocate, Pivotal

== The Need for Async IO
At Pivotal we see a lot of organizations moving to microservices. The architecture emphasizes small, singly focused, independently deployable pieces of functionality. They're small because small implies a smaller team working on the codebase. They're singly focused because it's easier to stay small that way. They're independently deployable because that means you're never blocked by other teams in the organization. The architecture has a lot of benefits; it supports organizational agility. But, the approach implies network distribution. The distribution in turn invites architectural complexity. Things get difficult when dependencies and networks fail. Things get difficult when the conduction of data between nodes becomes overwhelming.

Blocking IO makes the situation worse. When we say blocking, we mean that for a client to read a `byte` from a file or a socket (or whatever), it needs to wait for the `byte` to arrive. The thread in which the read is happening is idle, but unusable. On the JVM, where creating threads is very expensive, having wasted resources like this is all the more the pity. It doesn't need to be this way. At the lower levels in an operating system, network and file IO is typically asynchronous by default.

Java has always had `java.io.InputStream` and `java.io.OutputStream`, which are blocking abstractions. Java 1.4 saw the introduction of NIO (`java.nio.*`), the _new_ IO packages. NIO supports asynchronous IO - it provides a way to open a resource and be notified when there is new data, while not blocking the reading thread. This is a marked improvement but you'll notice that it hasn't exactly become the pervasive metaphor for computation. These days almost all of the APIs typical of enterprise  computing are blocking by default and you probably don't even realize it. Hopefully, most of us aren't writing data access layers, HTTP web stacks, and security integrations ourselves. We're relying on tried and true implementations that sit below the value line, below the line of things that we feel the need to expend cognitive effort trying to understand. Our business application is what matters, and so most frameworks let us think about the world in terms of our business domain, relegating IO concerns to the murky depths of the of the framework, the data access layer, etc.

We think about the world in terms of instances of our domain model entities, `T`, or collections of `T`. They are synchronous views on data. The `CompletableFuture<T>` gives us an asynchronous views of a single value. It lets us say that, _eventually_, we'll have a reference to a `T`. We haven't had for the longest time a way to say that we have a potentially infinite collection of type `T` that may or may not arrive, _eventually_.

Such a metaphor would need to be coupled with a way to gate the production and consumption of values. In the world of finite data sets, producers may occasionally overwhelm consumers but a consumer can buffer extra work, allowing it to eventually get to it. This works because the buffer is sufficient to absorb the overwhelming demand. What happens if the production is infinite? Eventually, like occupants in a leaky boat desperately trying to bail out the ocean, the consumer will sink. This is called flow control, and it needs to be a first class feature of any computational metaphor we choose.




// == Reactive Spring
// So you've got that shiny new distributed runtime, infinite greenfield potential, and lots of existing applications; now what?((("application forklifting", id="ix_appfork")))
// Alternatively, you can specify the buildpack in the `manifest.yml` file that accompanies your application. As an example, suppose we have a Java EE application that has historically been deployed using IBM's WebSphere. IBM maintains a very capable WebSphere Liberty buildpack. To demonstrate this, let's say we want to deploy and run a basic  `Servlet` (<<example0502>>). (Let's ignore, for now, that we can run `Servlet` components in Spring Boot applications, as shown in <<using-servlet-apis-in-a-spring-boot-application>>.)
//
// [[example0502]]
// .A (very) basic Java EE Servlet
// ====
// [source,java,indent=0]
// ----
// include::{book-root}/forklifting/buildpacks/src/main/java/demo/DemoApplication.java[]
// ----
// ====
